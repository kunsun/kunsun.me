<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kunsun</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kunsun.me/"/>
  <updated>2016-03-03T14:37:47.000Z</updated>
  <id>http://kunsun.me/</id>
  
  <author>
    <name>yangkun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>连笔字书写 API文档</title>
    <link href="http://kunsun.me/2015/11/04/2015-10-30-wringting-api/"/>
    <id>http://kunsun.me/2015/11/04/2015-10-30-wringting-api/</id>
    <published>2015-11-04T10:27:00.000Z</published>
    <updated>2016-03-03T14:37:47.000Z</updated>
    
    <content type="html">&lt;p&gt;连笔字书写目前做的是汉字的展示和练习。 展示主要指标准字。练习指自己也可以在画布上练习写字。写好一个字之后，需要把多个字放入一个页面中。页面是多个字的组合，可以是对联，也可以是成语。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;面向对象思路&quot;&gt;&lt;a href=&quot;#面向对象思路&quot; class=&quot;headerlink&quot; title=&quot;面向对象思路&quot;&gt;&lt;/a&gt;面向对象思路&lt;/h3&gt;&lt;p&gt;将字看做一个对象，命名为Character,单个字的操作都交给它处理。 例如，字的书写、字大小变化、字位置平移。 将页面看做一个对象，这里以成语为例（因为够简单），字与字之间的关系都交给它处理。例如，添加字、删除字、获取当前操作的是哪个字。 &lt;/p&gt;
&lt;h3 id=&quot;Character-js-介绍&quot;&gt;&lt;a href=&quot;#Character-js-介绍&quot; class=&quot;headerlink&quot; title=&quot;Character.js 介绍&quot;&gt;&lt;/a&gt;Character.js 介绍&lt;/h3&gt;&lt;p&gt;Character.js中只有Character一个对象， 使用立即执行函数封装所有变量，只通过window[‘Character’] = Character，使Character可以被访问。因为需要用到Lodash这个库的extend和cloneDeep方法，通过(function(/&lt;em&gt;){})(/&lt;/em&gt;)引入（和引入JQuery类似）。然后Character对象的创建使用最常用的对象创建方法：构造函数模式和原型模式混成的模式（参见：《Javascript高级程序设计第三版》159页）。&lt;br&gt;写一个字需要两部分，数据和控制参数。 数据就是strokeArray（笔画数组）,参数就是opts（控制参数）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Options：&lt;br&gt;默认的opts：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Character.defaultOpts = {
  gaussian: 1.3,
  wmax: 13.0,
  wmin: 2.0,
  timeScale: 15,
  radius: 5,
  lineWidth: 1.2,
  displayMode: {
     brush: 1,
     skeleton: 0,
    strokeColor: 0,
    animation: 0,
    uniformWidth: 0
  },
  strokeColors: [&amp;apos;black&amp;apos;, &amp;apos;gray3&amp;apos;, &amp;apos;gray2&amp;apos;, &amp;apos;gray1&amp;apos;],
  isXML: false,
  background: &amp;quot;#fff&amp;quot;,
  charRatio: 0.85,
   aspectRatio: 4/3,
   aspectWidth: 500,
   charBoxWidth: 500,
   startPosition: {
      x: 0,
      y: 0
   },
   };
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;各个参数的含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gaussian: 高斯系数&lt;/li&gt;
&lt;li&gt;wmax: 笔画最大宽度&lt;/li&gt;
&lt;li&gt;wmin: 笔画最小宽度&lt;/li&gt;
&lt;li&gt;timeScale: xml字的时间缩放，时间-&amp;gt;速度-&amp;gt;宽度。&lt;/li&gt;
&lt;li&gt;radius: 骨架字中小圆圈的半径&lt;/li&gt;
&lt;li&gt;lineWidth: 骨架字的笔画的宽度&lt;/li&gt;
&lt;li&gt;displayMode: 显示状态：标准字状态，骨架字状态，显示动画状态，标准宽度状态，笔画分颜色状态。&lt;/li&gt;
&lt;li&gt;strokeColors: 笔画的可选颜色&lt;/li&gt;
&lt;li&gt;isXML: xml文件标记&lt;/li&gt;
&lt;li&gt;aspectWidth: canvas视窗的宽度&lt;/li&gt;
&lt;li&gt;aspectRatio: canvas视窗的宽高比&lt;/li&gt;
&lt;li&gt;charBoxWidth: 写单字区域的宽度&lt;/li&gt;
&lt;li&gt;charRatio: 字占写字框的比例&lt;/li&gt;
&lt;li&gt;startPosition: 写单字的开始位置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;核心method：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;changeXY(strokeArray, opts): 根据参数opts，更新strokeArray，目前可以改变单个点的x,y,w数值，因为t,p,v不影响字的绘制，所以没有更改。&lt;/li&gt;
&lt;li&gt;drawAllPoint（canvas, strokeArray）: 依据字的坐标(x,y)和宽度w数据，绘制到指定canvas上。&lt;br&gt;外部只需要调用两个方法就OK。&lt;h3 id=&quot;Idiom-js介绍&quot;&gt;&lt;a href=&quot;#Idiom-js介绍&quot; class=&quot;headerlink&quot; title=&quot;Idiom.js介绍&quot;&gt;&lt;/a&gt;Idiom.js介绍&lt;/h3&gt;每个页面需要三部分， 改变参数之前的字的数组charArrayOrigin， 改变参数后的字的数组charArray和页面的控制参数opts。&lt;br&gt;有三个数据很关键， charArray是当前页中的所有字的数据，charArrayOrigin是当前页中的所有字的原始数据（参数未做改变）,charPointer当前操作的字的指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Options:&lt;br&gt;默认的Opts:   &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;aspectWidth:600,
aspectRatio: 1/3,
charBoxWidth: 150,
charBoxRatio: 4/3   
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;各个参数的含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;aspectWidth: canvas的宽度&lt;/li&gt;
&lt;li&gt;aspectRatio: canvas的宽高比&lt;/li&gt;
&lt;li&gt;charBoxWidth: 写单字区域的宽高比， 和Character的同名参数对应，需要传递过去。&lt;/li&gt;
&lt;li&gt;charBoxRatio: 宽高比&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;核心method: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;addChar(strokeArray,opts): 先将传入的数据添加到charArrayOrigin,改变字的startPosition和charBoxWidth后，将数据添加到charArray中。&lt;/li&gt;
&lt;li&gt;removeChar: charPointer向后移动一个单位&lt;/li&gt;
&lt;li&gt;clearChar: 清除当前charPointer上的数据&lt;/li&gt;
&lt;li&gt;getChar: 获取当前操作区域的字数据&lt;/li&gt;
&lt;li&gt;&lt;p&gt;getChar: 获取当前操作区域的字原始数据&lt;/p&gt;
&lt;h3 id=&quot;如何使用和Demo&quot;&gt;&lt;a href=&quot;#如何使用和Demo&quot; class=&quot;headerlink&quot; title=&quot;如何使用和Demo&quot;&gt;&lt;/a&gt;如何使用和Demo&lt;/h3&gt;&lt;p&gt;首先需要引入这三个js文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;js/lodash.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src = &amp;quot;js/character.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src = &amp;quot;js/idiom.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;        
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1 默认写字画布：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;html: &amp;lt;canvas id=&amp;quot;canvas&amp;quot; &amp;gt;不支持&amp;lt;/canvas&amp;gt;
js: var canvas = document.getElementById(&amp;apos;canvas&amp;apos;);
    var char = new Character(canvas);      
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2 canvas宽度为300和高斯系数为2.0的画布：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;html: &amp;lt;canvas id=&amp;quot;canvas&amp;quot; &amp;gt;不支持&amp;lt;/canvas&amp;gt;
js: var canvas = document.getElementById(&amp;apos;canvas&amp;apos;);
    var char = new Character(canvas,{gaussian:2.0, aspectWidth:     300});            
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;~/15-51-26.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3 宽度为400，可显示xml标准字的画布：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;html: &amp;lt;canvas id=&amp;quot;canvas&amp;quot; &amp;gt;不支持&amp;lt;/canvas&amp;gt;
      &amp;lt;input type=&amp;quot;file&amp;quot; id=&amp;quot;xmlfile&amp;quot; name=&amp;quot;xml&amp;quot; accept=&amp;quot;application/xml&amp;quot; title=&amp;quot;选择xml格式文字&amp;quot; /&amp;gt;     
js: var canvas = document.getElementById(&amp;apos;canvas&amp;apos;);
    var xmlFile = document.getElementById(&amp;apos;xmlfile&amp;apos;);
    var char = new Character(canvas,{isXML:true, gaussian:2.0, },xmlFile );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;~/15-59-28.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;4 默认成语画布：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;html: &amp;lt;canvas id=&amp;quot;canvas&amp;quot; &amp;gt;不支持&amp;lt;/canvas&amp;gt;
js: var canvas = document.getElementById(&amp;apos;canvas&amp;apos;);
    var char = new Idiom(canvas);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5 宽度aspectWidth变为400，单字charBoxWidth变为100的画布：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;html: &amp;lt;canvas id=&amp;quot;canvas&amp;quot; &amp;gt;不支持&amp;lt;/canvas&amp;gt;
js: var canvas = document.getElementById(&amp;apos;canvas&amp;apos;);
    var char = new Idiom(canvas,{aspectWidth:400,charWidth:100});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;6 把写好的字添加到页面中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示意代码：
idiom.addChar(char.strokeArray, char.opts);
 char.changeXY(
    idiom.charArray[idiom.charPointer-1].strokeArray
    ,
    idiom01.charArray[idiom.charPointer-1].opts
);
char.drawAllPoints(canvas, idiom.charArray[idiom01.charPointer-1].strokeArray);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;OK~ 以上就是目前两个对象的介绍。 基本框架已经ok，后续可能会继续封装一些内容进去。 如字对象可以尝试把参数调节UI控件和显示状态UI控件都封装进去。完。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;连笔字书写目前做的是汉字的展示和练习。 展示主要指标准字。练习指自己也可以在画布上练习写字。写好一个字之后，需要把多个字放入一个页面中。页面是多个字的组合，可以是对联，也可以是成语。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>NodeList和HTMLCollection的区别</title>
    <link href="http://kunsun.me/2015/06/13/2015-06-13-HTMLCollection&NodeList/"/>
    <id>http://kunsun.me/2015/06/13/2015-06-13-HTMLCollection&NodeList/</id>
    <published>2015-06-12T16:00:00.000Z</published>
    <updated>2016-03-03T14:37:47.000Z</updated>
    
    <content type="html">&lt;p&gt;NodeList和HTMLCollection是Dom中两个非常相似的概念，今天研究了一小会会，总结一下下。&lt;/p&gt;
&lt;p&gt;都是array-like object&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;getElementsByName(),Node.childNodes,document.querySelectorAll返回NodeList对象，而类似getElementsByTagName(),document.images() 和 document.forms() 的属性为HTMLCollection对象。&lt;/p&gt;
&lt;p&gt;都是只读的类数组对象。 有length属性。 &lt;/p&gt;
&lt;p&gt;不能直接在NodeList和HTML集合上调用Array方法，但可以简介的使用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var content = Array.prototype.map.call(document.getElementsByTagName(&amp;quot;p&amp;quot;),function(e){ return e.innerHTML; });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;NodeList和HTMLCollection对象不是历史文档状态的一个静态快照，而通常是实时的，并且当文档变化时他们所包含的元素列表能随之改变。 &lt;/p&gt;
&lt;p&gt;They differ in the methods they provide and in the type of nodes they can contain. While a NodeList can contain any noe type, an HTMLCollection is supposed to only contain Element nodes.&lt;/p&gt;
&lt;p&gt;An HTMLCollection provides the same methods as a NodeList and additionally amethod called namedItem.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/15763358/difference-between-htmlcollection-nodelists-and-arrays-of-objects&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Difference between HTMLCollection, NodeLists, and arrays of objects&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;NodeList和HTMLCollection是Dom中两个非常相似的概念，今天研究了一小会会，总结一下下。&lt;/p&gt;
&lt;p&gt;都是array-like object&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>A*算法</title>
    <link href="http://kunsun.me/2015/06/09/2015-06-09-A-star/"/>
    <id>http://kunsun.me/2015/06/09/2015-06-09-A-star/</id>
    <published>2015-06-08T16:00:00.000Z</published>
    <updated>2016-03-03T14:37:47.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;/img/A-star.jpg&quot; alt=&quot;Kunsun&quot; title=&quot;A star&quot;&gt;&lt;/p&gt;
&lt;p&gt;因为算法设计课需要讲算法，阿飞推介的A*算法，正好也与游戏相关，所以就花了一整天时间研究了一下。顺利完成。附图一张。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;一只探路猫&quot;&gt;&lt;a href=&quot;#一只探路猫&quot; class=&quot;headerlink&quot; title=&quot;一只探路猫&quot;&gt;&lt;/a&gt;一只探路猫&lt;/h4&gt;&lt;p&gt;有一款游戏， 游戏中一只猫想要找到获取骨头的路线。猫想找到到达骨头的最短路径。&lt;/p&gt;
&lt;h4 id=&quot;简化搜索区域&quot;&gt;&lt;a href=&quot;#简化搜索区域&quot; class=&quot;headerlink&quot; title=&quot;简化搜索区域&quot;&gt;&lt;/a&gt;简化搜索区域&lt;/h4&gt;&lt;p&gt;寻路的第一步是简化成容易控制的搜索区域。 使用正方形是作为寻路的单元最简单的。&lt;/p&gt;
&lt;h4 id=&quot;Open和Closed列表&quot;&gt;&lt;a href=&quot;#Open和Closed列表&quot; class=&quot;headerlink&quot; title=&quot;Open和Closed列表&quot;&gt;&lt;/a&gt;Open和Closed列表&lt;/h4&gt;&lt;p&gt;需要两个列表：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个记录所有被考虑来寻找最短路径的方块（称为open列表）&lt;/li&gt;
&lt;li&gt;一个记录下不会再被考虑的方块（称为closed列表）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;开始点称为A。结束点称为B。 首先在closed列表中添加当前位置。 然后，把所有与它当前位置相邻的可通行小方块添加到open列表中。需要判断在open列表中哪项才是最短路径， 需要给每一个方块的值，这个值被称为路径增量。&lt;/p&gt;
&lt;h4 id=&quot;路径增量&quot;&gt;&lt;a href=&quot;#路径增量&quot; class=&quot;headerlink&quot; title=&quot;路径增量&quot;&gt;&lt;/a&gt;路径增量&lt;/h4&gt;&lt;p&gt;给每一个方块一个G+H值，称为F：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;G是从开始点A到当前方块的移动量。相邻小方块的移动量为1，所以G值会越远越大。&lt;/li&gt;
&lt;li&gt;H是当前方块到目标点得移动量估算值。 这个称为探视，这仅仅是个估算值，因为我们不确定移动量是多少。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是关于G值和H值的详细分析。&lt;/p&gt;
&lt;h4 id=&quot;关于G值&quot;&gt;&lt;a href=&quot;#关于G值&quot; class=&quot;headerlink&quot; title=&quot;关于G值&quot;&gt;&lt;/a&gt;关于G值&lt;/h4&gt;&lt;p&gt;这个简单。&lt;/p&gt;
&lt;h4 id=&quot;关于H值&quot;&gt;&lt;a href=&quot;#关于H值&quot; class=&quot;headerlink&quot; title=&quot;关于H值&quot;&gt;&lt;/a&gt;关于H值&lt;/h4&gt;&lt;p&gt;移动量估算值离真实值越接近，最终的路劲会更加精确。为了简化问题， 我们使用曼哈顿长。 就是计算距离点B剩下的水平和垂直的方块数量，略去了障碍物或者不同陆地类型的数量。&lt;/p&gt;
&lt;h4 id=&quot;A星算法&quot;&gt;&lt;a href=&quot;#A星算法&quot; class=&quot;headerlink&quot; title=&quot;A星算法&quot;&gt;&lt;/a&gt;A星算法&lt;/h4&gt;&lt;p&gt;A星算法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将方块添加到open列表中，该列表有最小的和值。 称此方块为S。&lt;/li&gt;
&lt;li&gt;将S从open列表中移除，然后添加S到closed列表中。&lt;/li&gt;
&lt;li&gt;对于与S相邻的每一块可通行的方块T：&lt;ol&gt;
&lt;li&gt;如果T在closed列表中，不管。&lt;/li&gt;
&lt;li&gt;如果T不在open列表中，添加且计算和值。&lt;/li&gt;
&lt;li&gt;如果T已经在open列表中：检查F是否更小，如果是更新它的和值和前继。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;猫的路径&quot;&gt;&lt;a href=&quot;#猫的路径&quot; class=&quot;headerlink&quot; title=&quot;猫的路径&quot;&gt;&lt;/a&gt;猫的路径&lt;/h4&gt;&lt;p&gt;通过猫的例子， 详细说明A*算法。&lt;/p&gt;
&lt;p&gt;####&lt;/p&gt;
&lt;p&gt;因为A*算法采用了一套特殊的启发式评价公式将许多明显为坏得路劲排除考虑，进而快速计算出一条满意的路劲。&lt;/p&gt;
&lt;p&gt;启发式评价公式： F= G+H&lt;/p&gt;
&lt;p&gt;H主导A*算法的表现方式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;H=0: A*算法等同于Dijkstra演算法，并且保证能找到最短路劲。&lt;/li&gt;
&lt;li&gt;H&amp;lt; 目前节点到结束点的距离：A*算法能保证找到最短路劲，H越小，搜寻深度越深。&lt;/li&gt;
&lt;li&gt;H=目前节点到结束点得距离：A*算法会寻找最佳路劲，并且能够快速找到结果。&lt;/li&gt;
&lt;li&gt;H&amp;gt;目前节点到结束点的距离： 不能保证找到最短路劲，但计算比较快。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;伪代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Add START to OPEN list
while OPEN not empty
    get node n from OPEN that has the lowest f(n)
    if n is GOAL then return path
    move n to CLOSED
    for each n&amp;apos; = CanMove(n, direction)
        g(n&amp;apos;) = g(n) + 1
        calculate h(n&amp;apos;)
        if n&amp;apos; in OPEN list and new n&amp;apos; is not better, continue
        if n&amp;apos; in CLOSED list and new n&amp;apos; is not better, continue
        remove any n&amp;apos; from OPEN and CLOSED
        add n as n&amp;apos;s parent
        add n&amp;apos; to OPEN
    end for
end while

if we get to here, then there is No Solution
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/img/A-star.jpg&quot; alt=&quot;Kunsun&quot; title=&quot;A star&quot;&gt;&lt;/p&gt;
&lt;p&gt;因为算法设计课需要讲算法，阿飞推介的A*算法，正好也与游戏相关，所以就花了一整天时间研究了一下。顺利完成。附图一张。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Javascript编码风格</title>
    <link href="http://kunsun.me/2015/06/09/2015-06-09-javascript-style-guide/"/>
    <id>http://kunsun.me/2015/06/09/2015-06-09-javascript-style-guide/</id>
    <published>2015-06-08T16:00:00.000Z</published>
    <updated>2016-03-03T14:37:47.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;function&quot;&gt;&lt;a href=&quot;#function&quot; class=&quot;headerlink&quot; title=&quot;####function&quot;&gt;&lt;/a&gt;####function&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;参照github上的&lt;a href=&quot;https://github.com/airbnb/javascript/tree/master/es5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文章&lt;/a&gt;。权当是学习笔记。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Anonymous function expressions hoist their variable name,but not the function assignment.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function example() {
      console.log(anonymous); // =&amp;gt; undefined
      anonymous(); // =&amp;gt; TypeError anonymous is not a function
      var anonymous = function() {
        console.log(&amp;apos;anonymous function expression&amp;apos;);
      };
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Function declarations hoist their name and the function body.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function example() {
      superPower(); // =&amp;gt; Flying
      function superPower() {
        console.log(&amp;apos;Flying&amp;apos;);
      }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;条件判断中使用shortcuts。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// bad
if (name !== &amp;apos;&amp;apos;) {
      // ...stuff...
}
// good
if (name) {
  // ...stuff...
}
// bad
if (collection.length &amp;gt; 0) {
  // ...stuff...
}
// good
if (collection.length) {
  // ...stuff...
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;comments&quot;&gt;&lt;a href=&quot;#comments&quot; class=&quot;headerlink&quot; title=&quot;####comments&quot;&gt;&lt;/a&gt;####comments&lt;/h2&gt;&lt;p&gt;Use /&lt;em&gt;* … &lt;/em&gt;/ for multi-line comments. Include a description,specify types and values for all parameters and return values.&lt;/p&gt;
&lt;p&gt;Place single line comments on a newline above the subject of the comment.Put an empty line before the comment.&lt;/p&gt;
&lt;p&gt;Prefixing you comments with FIXME or TODO helps other developers quickly understand if you’re pointing out a problem that need to be revisited, or if you’re suggesting a solution to the problem that needs to be implemented.&lt;/p&gt;
&lt;h2 id=&quot;whitespace&quot;&gt;&lt;a href=&quot;#whitespace&quot; class=&quot;headerlink&quot; title=&quot;####whitespace&quot;&gt;&lt;/a&gt;####whitespace&lt;/h2&gt;&lt;p&gt;Place 1 space before the leading brace.&lt;/p&gt;
&lt;p&gt;Place 1 space before the opening parenthesis in control statements. &lt;/p&gt;
&lt;p&gt;Place no space before the argument list in function calls and declarations. &lt;/p&gt;
&lt;p&gt;Set off operators with spaces.&lt;/p&gt;
&lt;p&gt;Leave a blank line after blocks and before the next statement.&lt;/p&gt;
&lt;h2 id=&quot;naming&quot;&gt;&lt;a href=&quot;#naming&quot; class=&quot;headerlink&quot; title=&quot;####naming&quot;&gt;&lt;/a&gt;####naming&lt;/h2&gt;&lt;p&gt;Use a leading underscore _ when naming private properties.&lt;/p&gt;
&lt;p&gt;When saving a reference to this use _this.&lt;/p&gt;
&lt;p&gt;Name your function.This is helpful for stack traces.&lt;/p&gt;
&lt;h2 id=&quot;accessors&quot;&gt;&lt;a href=&quot;#accessors&quot; class=&quot;headerlink&quot; title=&quot;####accessors&quot;&gt;&lt;/a&gt;####accessors&lt;/h2&gt;&lt;p&gt;If you do make accesspr functions use getVal() and setVal(‘hello’).&lt;/p&gt;
&lt;h4 id=&quot;constructors&quot;&gt;&lt;a href=&quot;#constructors&quot; class=&quot;headerlink&quot; title=&quot;constructors&quot;&gt;&lt;/a&gt;constructors&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;Assign methods to the prototype object, instead of overwriting the prototype with a new object. &lt;/p&gt;
&lt;p&gt;Methods can return this to help with method chaining.&lt;/p&gt;
&lt;h4 id=&quot;jQuery&quot;&gt;&lt;a href=&quot;#jQuery&quot; class=&quot;headerlink&quot; title=&quot;jQuery&quot;&gt;&lt;/a&gt;jQuery&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;Prefix jQuery object variables with a $.&lt;/p&gt;
&lt;p&gt;Cache jQuery lookups.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;function&quot;&gt;&lt;a href=&quot;#function&quot; class=&quot;headerlink&quot; title=&quot;####function&quot;&gt;&lt;/a&gt;####function&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;参照github上的&lt;a href=&quot;https://github.com/airbnb/javascript/tree/master/es5&quot;&gt;文章&lt;/a&gt;。权当是学习笔记。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS布局</title>
    <link href="http://kunsun.me/2015/06/02/2015-06-02-css-layout/"/>
    <id>http://kunsun.me/2015/06/02/2015-06-02-css-layout/</id>
    <published>2015-06-01T16:00:00.000Z</published>
    <updated>2016-03-03T14:37:47.000Z</updated>
    
    <content type="html">&lt;p&gt;今天中午睡了一小会儿， 醒来到现在1个小时多点，读了这篇&lt;a href=&quot;http://zh.learnlayout.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSS布局的文章&lt;/a&gt;，感觉有所收获，顾文之。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;每个元素都有一个默认的display类型， 不过你可以随时的重写它。&lt;/p&gt;
&lt;p&gt;设置块级元素左右边距为auto，可以使得水平居中。&lt;/p&gt;
&lt;p&gt;使用max-width  代替width可以适应小窗口的情况。IE7+支持max-width.&lt;/p&gt;
&lt;p&gt;当设置一个元素的 box-sizing: border-box; 时，此元素的内边距和边框，不会增加它的宽度了。IE8+支持max-width.&lt;/p&gt;
&lt;p&gt;一个元素的默认Position值是static， 如果没有设置为其他的值， 那么它不会被定位的。&lt;br&gt;relative表现和static本来一样，在元素上设置上下左右可以改变它位置，其他元素不会受它影响调整位置。&lt;br&gt;fixed在移动浏览器中的支持很差，但是有相应的&lt;a href=&quot;http://bradfrostweb.com/blog/mobile/fixed-position/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;解决方案&lt;/a&gt;。&lt;br&gt;absolute是相对于最近的没有“positioned”元素定位的。&lt;/p&gt;
&lt;h3 id=&quot;布局可以用好几种方法实现：&quot;&gt;&lt;a href=&quot;#布局可以用好几种方法实现：&quot; class=&quot;headerlink&quot; title=&quot;布局可以用好几种方法实现：&quot;&gt;&lt;/a&gt;布局可以用好几种方法实现：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;position：&quot;&gt;&lt;a href=&quot;#position：&quot; class=&quot;headerlink&quot; title=&quot;position：&quot;&gt;&lt;/a&gt;position：&lt;/h4&gt;可以使用.container设置relative， 然后nav设置absolute, 然后content设置margin-left.&lt;/li&gt;
&lt;li&gt;&lt;h4 id=&quot;float：&quot;&gt;&lt;a href=&quot;#float：&quot; class=&quot;headerlink&quot; title=&quot;float：&quot;&gt;&lt;/a&gt;float：&lt;/h4&gt;使用float属性。 使用float很爽，但是要清楚之后的垃圾却有点费劲。请看做好的&lt;a href=&quot;http://stackoverflow.com/questions/211383/which-method-of-clearfix-is-best&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;clearfix方法&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;h4 id=&quot;百分比：&quot;&gt;&lt;a href=&quot;#百分比：&quot; class=&quot;headerlink&quot; title=&quot;百分比：&quot;&gt;&lt;/a&gt;百分比：&lt;/h4&gt;使用这个方法的好处，就是在做响应式设计的时候会省事。&lt;/li&gt;
&lt;li&gt;&lt;h4 id=&quot;inline-block&quot;&gt;&lt;a href=&quot;#inline-block&quot; class=&quot;headerlink&quot; title=&quot;inline-block&quot;&gt;&lt;/a&gt;inline-block&lt;/h4&gt;这个属性可以代替掉float。 但是IE8+支持。需要和vertical-align一起使用。&lt;/li&gt;
&lt;li&gt;&lt;h4 id=&quot;column&quot;&gt;&lt;a href=&quot;#column&quot; class=&quot;headerlink&quot; title=&quot;column&quot;&gt;&lt;/a&gt;column&lt;/h4&gt;这是非常新的属性。 IE10+。&lt;/li&gt;
&lt;li&gt;&lt;h4 id=&quot;flex&quot;&gt;&lt;a href=&quot;#flex&quot; class=&quot;headerlink&quot; title=&quot;flex&quot;&gt;&lt;/a&gt;flex&lt;/h4&gt;介绍最后一个牛逼的方法，就是flex。 IE10+。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天中午睡了一小会儿， 醒来到现在1个小时多点，读了这篇&lt;a href=&quot;http://zh.learnlayout.com/&quot;&gt;CSS布局的文章&lt;/a&gt;，感觉有所收获，顾文之。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Modernizr分析</title>
    <link href="http://kunsun.me/2015/05/30/2015-05-30-modernizr/"/>
    <id>http://kunsun.me/2015/05/30/2015-05-30-modernizr/</id>
    <published>2015-05-29T16:00:00.000Z</published>
    <updated>2016-03-03T14:37:47.000Z</updated>
    
    <content type="html">&lt;p&gt;一直认为学习一个工具或者一门语言做好的方法就是看原生文档， 这次&lt;a href=&quot;http://modernizr.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Modernizr&lt;/a&gt;的学习再次确认了这个想法。 因为之前几天偷懒，三三两两的看关于Modernizr的中文文档，远没有今天专注花两个小时阅读&lt;a href=&quot;http://modernizr.com/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;管用。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;Modernizr会告诉你当前使用的浏览器是否原生支持了这些HTML5和CSS3特性。&lt;/p&gt;
&lt;h3 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h3&gt;&lt;p&gt;Javascript客户端检测有三种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能力检测，也称为特征检测feature detection&lt;/li&gt;
&lt;li&gt;怪癖检测quirks detection&lt;/li&gt;
&lt;li&gt;还有用户代理检测,使用navigator.userAgent&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Modernizr使用的就是最为人们广泛接受的能力检测，代替用户代理检测，这种方式不必顾及特定的浏览器如何如何，只要确定浏览器支持特定的能力，就可以给出解决方案。&lt;/p&gt;
&lt;p&gt;Modernizr并不是使用JavScript动态地加载不同的样式表，而是使用非常简单的技术，将类添加到页面的&lt;html&gt;标签。 如果页面支持box-shadow属性， 那么Modernizr会添加boxshadow类。 如果不支持，那么它会用no-boxshadow类作为替代进行添加。&lt;/html&gt;&lt;/p&gt;
&lt;h3 id=&quot;Modernizr与html5shiv的区别&quot;&gt;&lt;a href=&quot;#Modernizr与html5shiv的区别&quot; class=&quot;headerlink&quot; title=&quot;Modernizr与html5shiv的区别&quot;&gt;&lt;/a&gt;Modernizr与html5shiv的区别&lt;/h3&gt;&lt;p&gt;Stackexchange上的一条&lt;a href=&quot;http://webmasters.stackexchange.com/questions/11729/whats-the-difference-between-modernizr-and-html5shiv&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;回答&lt;/a&gt;说明了这个问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;顺便提一个非常有意思的话题，前端经常提到的&lt;a href=&quot;http://www.cnblogs.com/ziyunfei/archive/2012/09/17/2688829.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;shim与polyfill&lt;/a&gt;到底是什么？stackoverflow也有类似的&lt;a href=&quot;http://stackoverflow.com/questions/6599815/what-is-the-difference-between-a-shim-and-a-polyfill&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;讨论&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Modernizr与respondjs的关系&quot;&gt;&lt;a href=&quot;#Modernizr与respondjs的关系&quot; class=&quot;headerlink&quot; title=&quot;Modernizr与respondjs的关系&quot;&gt;&lt;/a&gt;Modernizr与respondjs的关系&lt;/h3&gt;&lt;p&gt;respondjs也是一个polyshiv。 如果生成Modernizr时包含了Media Query。那么两者都可以在旧版浏览器中实现媒体查询。下面这种写法是我认为的很好的实现方式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;Modernizr.mq(&amp;apos;(min-width:0)&amp;apos;) || document.write(&amp;apos;&amp;lt;script src=&amp;quot;js/libs/respond.min.js&amp;quot;&amp;gt;&amp;lt;\/script&amp;gt;&amp;apos;)&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也可以使用&lt;a href=&quot;http://yepnopejs.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Yepnope的方式&lt;/a&gt;。因为Modernizr的load方法自带有Yepnode。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这篇文章讲了如何使用respondjs实现responsive。&lt;a href=&quot;http://www.zell-weekeat.com/support-for-older-browsers/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How to Build a Responsive Website That Supports Older Browsers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;这篇&lt;a href=&quot;http://stackoverflow.com/questions/8273845/modernizr-with-respond-js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文章&lt;/a&gt;也讲了modernizr和respondjs的取舍问题。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.w3.org/community/webed/wiki/Optimizing_content_for_different_browsers:_the_RIGHT_way#Polyfills.2Fshims&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方推介&lt;/a&gt;的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Modernizr的方法&quot;&gt;&lt;a href=&quot;#Modernizr的方法&quot; class=&quot;headerlink&quot; title=&quot;Modernizr的方法&quot;&gt;&lt;/a&gt;Modernizr的方法&lt;/h3&gt;&lt;p&gt;modernizr提供了一些方法，在做CSS3操作和响应式设计的时候会很有用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;modernizr.prefixed():  会返回带有浏览器厂商前缀(browser vendor tag)的CSS属性。可以配合正则表达式处理字符串以及DOM Events事件判断。&lt;/li&gt;
&lt;li&gt;modernizr.addTest(): 用来测试目前modernizr不支持的特征，返回一个布尔值。如果true，则html标签中出现测试的属性，反之，出现no-属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是Modernizr最重要的两个方法。&lt;/p&gt;
&lt;p&gt;Github上的&lt;a href=&quot;&quot;&gt;这段代码&lt;/a&gt;是学习prefixed()与addTest()很好的示例。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Modernizr.addTest(&amp;apos;csstransformspreserve3d&amp;apos;, function () {

   var prop = Modernizr.prefixed(&amp;apos;transformStyle&amp;apos;);
   var val = &amp;apos;preserve-3d&amp;apos;;
   var computedStyle;
   if(!prop) return false;

   prop = prop.replace(/([A-Z])/g, function(str,m1){ return &amp;apos;-&amp;apos; + m1.toLowerCase(); }).replace(/^ms-/,&amp;apos;-ms-&amp;apos;);

   Modernizr.testStyles(&amp;apos;#modernizr{&amp;apos; + prop + &amp;apos;:&amp;apos; + val + &amp;apos;;}&amp;apos;, function (el, rule) {
       computedStyle = win.getComputedStyle ? getComputedStyle(el, null).getPropertyValue(prop) : &amp;apos;&amp;apos;;
   });

   return (computedStyle === val);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;Modernizr功能很多，所以在使用的时候也可以自己取舍使用polyfill还是Modernizr。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;之后的博文，尽量以一周三篇的频率更新。 主要还是前端的内容。 &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;一直认为学习一个工具或者一门语言做好的方法就是看原生文档， 这次&lt;a href=&quot;http://modernizr.com/&quot;&gt;Modernizr&lt;/a&gt;的学习再次确认了这个想法。 因为之前几天偷懒，三三两两的看关于Modernizr的中文文档，远没有今天专注花两个小时阅读&lt;a href=&quot;http://modernizr.com/docs/&quot;&gt;官方文档&lt;/a&gt;管用。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Classie.js源码分析</title>
    <link href="http://kunsun.me/2015/05/29/2015-05-29-classie.js/"/>
    <id>http://kunsun.me/2015/05/29/2015-05-29-classie.js/</id>
    <published>2015-05-28T16:00:00.000Z</published>
    <updated>2016-03-03T14:37:47.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;为什么要用classie-js&quot;&gt;&lt;a href=&quot;#为什么要用classie-js&quot; class=&quot;headerlink&quot; title=&quot;为什么要用classie.js&quot;&gt;&lt;/a&gt;为什么要用classie.js&lt;/h3&gt;&lt;p&gt;classie是一个 awesome,lightweight script。 用来添加，移除，toggleDom元素的类。那为什么不用jquery呢， 因为jquery相对于这几个简单的功能太冗余了(just too bloated for your needs)。 classie.js 只有简单的81行，去掉注释，仅有51行， 我们现在就来分析源码。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这一篇blog也介绍了classie.js&lt;a href=&quot;http://callmenick.com/post/add-remove-and-check-classes&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前往&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;怎么用&quot;&gt;&lt;a href=&quot;#怎么用&quot; class=&quot;headerlink&quot; title=&quot;怎么用&quot;&gt;&lt;/a&gt;怎么用&lt;/h3&gt;&lt;p&gt;classie只有4个方法，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hasClass&lt;/li&gt;
&lt;li&gt;addClass&lt;/li&gt;
&lt;li&gt;removeClass&lt;/li&gt;
&lt;li&gt;toggleClass&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;顾名思义。 使用classie只需要在js代码中，直接使用classie.hasClass等方法即可。方法中只需要传递两个参数，第一个是Element元素，第二个是需要操作的class名称。&lt;/p&gt;
&lt;h3 id=&quot;源码分析&quot;&gt;&lt;a href=&quot;#源码分析&quot; class=&quot;headerlink&quot; title=&quot;源码分析&quot;&gt;&lt;/a&gt;源码分析&lt;/h3&gt;&lt;p&gt;首先介绍一下classList属性， classList是HTML5为javascipt的class操作新增的API。之前在操作类名时，需要通过className属性，className属性是一个字符串，使用className操作类名会涉及到很多字符串处理，很麻烦。新增的classList属性简化了这些操作。下面的代码就是使用classList属性进行了class的操作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if ( &amp;apos;classList&amp;apos; in document.documentElement ) {
      hasClass = function( elem, c ) {
        return elem.classList.contains( c );
      };
      addClass = function( elem, c ) {
        elem.classList.add( c );
      };
      removeClass = function( elem, c ) {
        elem.classList.remove( c );
      };
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;支持className属性的浏览器有Firefox3.6+和Chrome。所以在低版本中使用了另外一种写法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;else {
      hasClass = function( elem, c ) {
        return classReg( c ).test( elem.className );
      };
      addClass = function( elem, c ) {
        if ( !hasClass( elem, c ) ) {
              elem.className = elem.className + &amp;apos; &amp;apos; + c;
        }
      };
      removeClass = function( elem, c ) {
        elem.className = elem.className.replace( classReg( c ), &amp;apos; &amp;apos; );
      };
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中classReg使用如下方法找到class ：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function classReg( className ) {
      return new RegExp(&amp;quot;(^|\\s+)&amp;quot; + className + &amp;quot;(\\s+|$)&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里使用的是对className属性进行字符串处理。&lt;/p&gt;
&lt;p&gt;最后加上toggleClass。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function toggleClass( elem, c ) {
      var fn = hasClass( elem, c ) ? removeClass : addClass;
      fn( elem, c );
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;classie.js源码分析如上。 附classie.js的&lt;a href=&quot;https://github.com/desandro/classie&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github地址&lt;/a&gt;。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么要用classie-js&quot;&gt;&lt;a href=&quot;#为什么要用classie-js&quot; class=&quot;headerlink&quot; title=&quot;为什么要用classie.js&quot;&gt;&lt;/a&gt;为什么要用classie.js&lt;/h3&gt;&lt;p&gt;classie是一个 awesome,lightweight script。 用来添加，移除，toggleDom元素的类。那为什么不用jquery呢， 因为jquery相对于这几个简单的功能太冗余了(just too bloated for your needs)。 classie.js 只有简单的81行，去掉注释，仅有51行， 我们现在就来分析源码。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网上博物馆各项目数据格式</title>
    <link href="http://kunsun.me/2015/05/11/2015-05-11-museum-data-format/"/>
    <id>http://kunsun.me/2015/05/11/2015-05-11-museum-data-format/</id>
    <published>2015-05-10T16:00:00.000Z</published>
    <updated>2016-03-03T14:37:47.000Z</updated>
    
    <content type="html">&lt;p&gt;由于北京语言文化网上博物馆的数据分类特别多，所以文章对所有的数据条目进行了一个整理。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;###吟诵：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;北京话吟诵：标题    标题图    吟诵者信息     视/音频    吟诵内容    说明    文件类型&lt;/li&gt;
&lt;li&gt;普通话吟诵：标题    标题图    吟诵者信息     视/音频    吟诵内容    说明（为空）    文件类型&lt;/li&gt;
&lt;li&gt;京外吟诵全景：标题    标题图    吟诵者信息     视/音频    吟诵内容    说明    文件类型&lt;/li&gt;
&lt;li&gt;吟诵录像教学： 标题    标题图    吟诵者信息     视/音频    吟诵内容    说明    文件类型&lt;br&gt;吟诵文献：两个docx文档&lt;br&gt;吟诵课件：10个ppt&lt;br&gt;吟诵论文： 数个docx文档&lt;br&gt;简介和什么是吟诵&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;###地名&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;地名：地名  地理位置   管辖   普通话音    北京音    繁体   介绍    扩展说明&lt;/li&gt;
&lt;li&gt;少简介&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;###方言土语&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方言土语：编号  图通话词条  北京话词条   读音   释义    声音   图片   类别&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;###北京话文献&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;北京话：类型，书名，作者，版本，出版社，年代，页数，简介，备注，封面。目录，pdf&lt;/li&gt;
&lt;li&gt;少pdf&lt;/li&gt;
&lt;li&gt;简介&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;###清代御诗&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;御制诗初集：标题，诗作，注释，所写年代，作者，照片&lt;/li&gt;
&lt;li&gt;乐善堂集：标题，诗作，注释，所写年代，作者，照片&lt;/li&gt;
&lt;li&gt;御制诗二集：标题，诗作，注释，所写年代，作者，照片&lt;/li&gt;
&lt;li&gt;御制诗三集：标题，诗作，注释，所写年代，作者，照片&lt;/li&gt;
&lt;li&gt;简介&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;###话说老北京&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;话说老北京：编号，普通话词条，北京话说法，读音，释义，声音，图片，类别&lt;/li&gt;
&lt;li&gt;简介&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;###叫卖&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发音人资料：名字，性别，年龄，地址，说明，图片&lt;/li&gt;
&lt;li&gt;叫卖视频： 标题，标题图快照，视频文件名，脚本xml，内容，表演者名字。 &lt;/li&gt;
&lt;li&gt;叫卖响器名物：道具名称，道具图片，道具说明 &lt;/li&gt;
&lt;li&gt;简介&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;###外语&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外语： 照片名，功能，类别1，类别2，拍摄日期，拍照人，评议人，地点，内容，评价。&lt;br&gt;简介&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;由于北京语言文化网上博物馆的数据分类特别多，所以文章对所有的数据条目进行了一个整理。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网上博物馆底层整体框架设计</title>
    <link href="http://kunsun.me/2015/05/11/2015-05-11-museum-framework-design/"/>
    <id>http://kunsun.me/2015/05/11/2015-05-11-museum-framework-design/</id>
    <published>2015-05-10T16:00:00.000Z</published>
    <updated>2016-03-03T14:37:47.000Z</updated>
    
    <content type="html">&lt;p&gt;###一、PHP框架&lt;br&gt;无论是从系统的稳定性，还是安全性来讲，将北京语言文化博物馆网站放到一个成熟框架中来开发是很切合实际的。&lt;/p&gt;
&lt;p&gt;北京语言文化网上博物馆使用的是Laravel框架，Laravel框架是目前最受欢迎的PHP框架。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Laravel是2014与2015年美国&lt;a href=&quot;http://www.sitepoint.com/best-php-frameworks-2014/&quot; title=&quot;title&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;最受欢迎的PHP框架&lt;/a&gt;，根据最受欢迎的PHP框架调查显示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###二、 设计模式&lt;br&gt;MVC是一种组织结构设计模式，也是包括Laravel在内的所有主流框架使用的架构。要想先讲清网站的框架，需要先清楚MVC设计模式。&lt;/p&gt;
&lt;p&gt;MVC的理念是将应用开发依据逻辑分隔为几个部分，然后各司其职，互有联系。它把应用分为了业务逻辑（即数据部分），用户界面（即视图部分），以及用于管理逻辑，用户输出，并在模型和视图中间起协调作用的控制部分（即控制器）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个模式最初由Trygve Reenskaug在使用Smalltalk-80语言时设计出，一开始它的名字叫做”模型-视图-控制器-编辑器”模式。《设计模式：可重用的面向对象软件元素》一书对MVC设计模式有详细的描述。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MVC设计模式中其实也包含一些很经典的设计模式，即观察者模式，当模型发生了变化，视图都会进行相应，更新视图和模型变化联系紧密。&lt;/p&gt;
&lt;p&gt;  其实MVC最初的设计并不是用来解决WEB中的问题的，那么MVC目前在WEB中是如何运用的呢。&lt;br&gt;  如下图所示：&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;http://htmljs.b0.upaiyun.com/uploads/1409725591244-webmvcflow_bacic.png&quot; alt=&quot;MVC&quot; title=&quot;MVC图示&quot;&gt;&lt;/p&gt;
&lt;p&gt;####MVC与WEB开发&lt;br&gt;先看看在web开发中，MVC的具体含义。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;####Model&lt;br&gt;  模型代表的是一个应用的的数据，一般一个模型都对应着一张数据表，通过模型来操作数据表，与数据库进行交互。&lt;/li&gt;
&lt;li&gt;####View&lt;br&gt;  视图代表用户界面，WEB应用都是以HTML的形式呈现，他们用来展示需要呈现给用户的数据。&lt;/li&gt;
&lt;li&gt;####Controller&lt;br&gt;  控制器是用来连接模型和视图的中间层。处理来自用户的请求，然后从模型中取出数据传递给视图。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在网上博物馆的设计上会扩展原有的Model, 对Model需要增加数据验证功能，给具体的Model添加验证器。另外也需要扩展Model的功能，在口传文化项目中一个模型对应三个数据库，分别叫卖视频，叫卖人，叫卖物品，三个数据表中是有联系的，所以也需要在Model中间建立表的联系。Laravel数据库操作使用的是Eloquent ORM，由于ORM内部的完善的设计，会使数据库操作更加方便和安全，不会有SQL注入等安全漏洞的出现。&lt;/p&gt;
&lt;p&gt;现在已经讲了MVC的具体含义了。但是有一个特别重要的概念还没有讲到。对于一个大型的应用，会有很多控制器来处理不同的请求。那么控制器是如何判断自己应该处理哪个请求呢。这里就用到了图示中的 &lt;em&gt;Front Controller&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;Front Controller实际上是一个路由控制器，用户发来一个请求，请求以路由的形式呈现，类似&lt;a href=&quot;http://example/post/3这样的形式。然后Front&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://example/post/3这样的形式。然后Front&lt;/a&gt; Controller会依据不同的路由请求，反馈给用户不同的控制器。所以首要的问题就是如何构造一个完整的&lt;em&gt;Routing&lt;/em&gt;（路由）表。&lt;/p&gt;
&lt;p&gt;###三、 路由设计&lt;/p&gt;
&lt;p&gt;网上博物馆的路由设计采取&lt;em&gt;REST&lt;/em&gt;（表征性状态传输）设计风格。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;REST是由Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。HTTP连接是无状态的，而REST传输会包含应用的所有状态信息，因此可以大幅降低对HTTP连接的重复请求资源消耗。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;REST有以下几个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;资源由URI来指定。&lt;/li&gt;
&lt;li&gt;对资源的操作包括获取、创建、修改和删除资源，这些操作正好与HTTP协议提供的GET,POST,DELETE方法对应。&lt;/li&gt;
&lt;li&gt;通过操作资源的表现形式来操作资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面的表格列出了实现RESTful API时HTTP请求方法的应用：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;资源&lt;/th&gt;
&lt;th&gt;GET&lt;/th&gt;
&lt;th&gt;POST&lt;/th&gt;
&lt;th&gt;DELETE&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;一组资源的URI，如&lt;a href=&quot;http://example/post&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://example/post&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;列出资源组中每个资源的信息，即列表展示&lt;/td&gt;
&lt;td&gt;在本组中新增或者修改资源&lt;/td&gt;
&lt;td&gt;删除整组资源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;单个资源的URI，如&lt;a href=&quot;http://example/post/3&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://example/post/3&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;获取指定资源的详细信息&lt;/td&gt;
&lt;td&gt;在当前组中修改，新增一条资源&lt;/td&gt;
&lt;td&gt;删除单个资源&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Laravel对RESTful资源控制器进行了细化，下表列出Laravel中由资源控制器处理的行为：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;动词&lt;/th&gt;
&lt;th&gt;路径&lt;/th&gt;
&lt;th&gt;行为&lt;/th&gt;
&lt;th&gt;路由名称&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/photo&lt;/td&gt;
&lt;td&gt;索引&lt;/td&gt;
&lt;td&gt;photo.index&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/photo/create&lt;/td&gt;
&lt;td&gt;创建&lt;/td&gt;
&lt;td&gt;photo.create&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;POST&lt;/td&gt;
&lt;td&gt;/photo&lt;/td&gt;
&lt;td&gt;保存&lt;/td&gt;
&lt;td&gt;photo.save&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/photo/{photo}&lt;/td&gt;
&lt;td&gt;显示&lt;/td&gt;
&lt;td&gt;photo.show&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/photo/{photo}/edit&lt;/td&gt;
&lt;td&gt;编辑&lt;/td&gt;
&lt;td&gt;photo.edit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PUT/PATCH&lt;/td&gt;
&lt;td&gt;photo/{photo}&lt;/td&gt;
&lt;td&gt;更新&lt;/td&gt;
&lt;td&gt;photo.update&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DELETE&lt;/td&gt;
&lt;td&gt;photo/{photo}&lt;/td&gt;
&lt;td&gt;删除&lt;/td&gt;
&lt;td&gt;photo.destroy&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;网上博物馆的路由设计完全依据REST的设计模式，将URI与资源联系起来。整体主要分为两个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;项目内容展示页的路由设计，采用“baseurl/项目名”与“baseurl/项目名/{id}”这两种路由分别展示列表页和详情页。然后再控制器Controller中再具体写index，show这两个方法。&lt;/li&gt;
&lt;li&gt;项目管理页的路由设计，采用“baseurl/admin/项目名”这种路由，将用户请求导引到具体的项目管理Controller，在控制器中添加index, create,store,show,edit,update, destroy方法。 就可以完成，项目管理页面中的增删改了。然后也可以把管理页面的路由作为API给各个项目的研究小组增加和修改数据条目。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;###四、视图模板设计&lt;br&gt;网上博物馆的WEB前端的页面设计，使用的是Blade模板引擎。&lt;/p&gt;
&lt;p&gt;网站的视图页面全部放在resources的views目录下。首页就放置到根目录下，然后将header和footer等固定不变的布局全部放到layouts文件夹中，然后admin文件夹放置所有的项目的管理页面，project文件夹放置所有项目的展示页面。 另外auth文件夹放置用户的注册、登录页面。 通过Blade模板引擎，可以轻松的继承布局，扩充项目。 页面内容和样式的更改也变得很简单。&lt;/p&gt;
&lt;p&gt;###五、网站发布&lt;br&gt;为了防止网站在不同的服务器环境显示有差异，网上博物馆使用Vagrant和Homestead构建一个虚拟机，搭建一个无论在Windows，Linux，Mac等任何系统上都能完美运行网站的环境。 这样一来大大增加了网站的可迁移性。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;###一、PHP框架&lt;br&gt;无论是从系统的稳定性，还是安全性来讲，将北京语言文化博物馆网站放到一个成熟框架中来开发是很切合实际的。&lt;/p&gt;
&lt;p&gt;北京语言文化网上博物馆使用的是Laravel框架，Laravel框架是目前最受欢迎的PHP框架。&lt;br&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://kunsun.me/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="模式" scheme="http://kunsun.me/tags/%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="WEB" scheme="http://kunsun.me/tags/WEB/"/>
    
  </entry>
  
</feed>
